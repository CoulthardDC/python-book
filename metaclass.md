# Метаклассы  

Метаклассы редко используются, но могут использоваться для расширения классов средствами вроде отслеживания, постоянства объектов, регистрации исключений и многого другого. С помощью метаклассов можно конструировать порции классов во время выпонления на основе конфигуроционных файлов, применять декораторы к методам класса обобщенным образом, проверять соответствие ожидаемых интерфейсов и т.д.  

Роли декораторов классов и метаклассов часто пересекаются.  

## Язык привязок  

Метаклассы в конечном итоге представляют собой еще один способ определения _автоматически запускаемого кода_. Python дает возможность вставлять логику в разнообразные контексты, среди которых выполнение операций, доступ к атрибутам, вызовы функций, создание экземпляров классов и теперь создание объектов классов. Это язык с  _изобилием привязок_ - средство, обеспечивающие гибкость, которая может потребоваться в рядах программ.  

Декараторы классов и метаклассы нередко могут использоваться взаимозаменяемо:  

* хотя декораторы классов часто применяются для управления экземплярами классов, они также могут применяться для управления управления классами почти как метаклассы.
* аналогично наряду с тем, что метаклассы предназначены для дополнения процедуры создания классов, они также могут вставлять посредников, для управления экземплярами почти как декораторы классов.  

Главное функциональное отличие между этими двумя инструментами касается момента, когда они активизируются в рамках _процесса_ создания классов. Декораторы классов запускаются _после_ того, как декорированный класс был создан. Таким образом, они часто применяются для добавления логики, подлежащей выполнению во время создания _экземпляра_. __Когда декораторы классов снабжают класс линией поведения, то обычно делают это через изменения или посредников, а не более непосредственное отношение__.  

Метаклассы запускаюстя _во время_ создания классов, чтобы создать и возвратить новый клиентский класс. Следовательно они часто используются для управления или дополнения самих _классов_ и могут даже предоставлять методы для обработки созданных из них классов через прямое отношение между экземплярами.  

Метаклассы можно применять для атоматического делегирования, регистрации всех используемых классов в API-интерфейсе, автоматического добавления к классам пользовательского интерфейса, создания или расширение классов на основе упрощенных спецификаций в текстовых файлах и т.д. Поскольку они способны управлять тем, как создаются классы, и через посредников поведением, которым обзаводятся их экземпляры, применимость метаклассов потенциально очень широка.  

## Недостаток "вспомогательных функций"  

Метаклассы:  

* обеспечивают более явную и формальную структуру;
* Помогают гарантировать, что прикладные программисты не забудут дополнить свои классы в соответствии с требованиями API-интерфейса;
* снижают избыточность кода и связанные с ней накладные расходы на сопровождение, вынося логику настройки классов в единственное место, т.е. в метаклассы.  

Предположим, что необходимо автоматически вставлять метод в набор классов. Данную задачу можно решить с помощью _наследования_:  

```python
class Extras:
    def extra(self, args): ...

class Client1(Extras): ...
class Client2(Extras): ...
class Client3(Extras): ...

X = Client1()
X.extra()
```  

Возьмем сценарий, когда классы дополняются в ответ на выбор, сделанный в пользовательском интерфейсе во время выполнения, или согласно спецификациям, введенным в конфигурационном файле. Несмотря на то что мы могли бы предусмотреть в каждом классе из нашего воображаемого набора код для ручной проверки этого, у клиентов придется выяснять множество вопросов (вызовы requiredздесь абстрактны и должны быть чем-то заполнены):  

```python
def extra(self, args): ...

def Client1: ...
if required():
    Client1.extra = extra

def Client2: ...
if required():
    Client2.extra = extra

X = Client1()
X.extra()
```  

С точки зрения сопроождения кода было бы лучше изолировать логику выбора в одном месте. Можно инкапсулировать часть дополнительной работы, пропуская классы через управляющую функцию, которая бы должным образом расширяла класс и выполняла всю работу по проверке и конфигурированию во время выполнения:  

```python
def extra(self, args):...

def extras(Class):              #Управляющая функция
    if required():
        Class.extra = extra
...
```  

Лучший способ - иметь возможность вставлять какой-то код, подлежащий _автоматическому_ запуску в конце оператора `class` для дополнения класса.  

Именно такую работу выполняют _метаклассы_ - объявляя метаклассы, интерпретатору сообзается о том, что процесс создания объекта класса должен быть направлен указанному нами другому классу:  

```python
def extra(self, arg): ...

class Extras:
    def __init__(Class, classname, superclasses, attributedict):
        if required():
            Class.extra = extra

class Client1(metaclass=Extras): ...
class Client2(metaclass=Extras): ...
class Client3(metaclass=Extras): ...

X = Client1()
X.extra()
```  

Поскольку интерпретатор Python автоматически активизирует метакласс в конце оператора `class`, когда новый класс создан, он может необходимым способом дополнять, регестрировать или по-другому управлять классом. Единственное требование к клиентским классам - они должны объявить метакласс.  

## Модель метаклассов  

Для понимания метаклассов необходимо больше знать о модели типов Python и о том, что происходит в конце оператора `class`.

### Классы являются экземплярами `type`  

В Python 3.X объекты классов, определяемых пользователем, представляют собой экземпляры объекта по имени `type`, который сам по сбебе является классом.

Встроенная функция `type` возвращает тип любого объекта (который тоже объект), когда вызывается с единственным аргументом. Но типом самого типа (напрмер встроенный списковый тип) оказывается сам `type` - объекта `type` на вершине иерархии создает индивидуальные типы, а индивидуальные типы создают экземпляры.  

```python
print(type([]))             #<class 'list'>
print(type(type([])))       #<class 'type'>
```

В Python 3.X _классы являются типами, а типы являются классами_. Т.е.:
* типы определяются классами, которые унаследовали `type`.
* определяемые пользователем классы являются экземплярами класса `type`.
* определяемые пользователем классы представляют собой тип, который генерирует собственные экземпляры.  

Т.е. все определяемые пользователем классы в Python 3.X являются экземплярами касса `type`, а объекты экземпляров - экземплярами своих классов. В действительности классы теперь имеют атрибут `__class__`, ссылающийся на `type`, точно также как экземпляр имеет атрибут `__class__`, ссылающийся на класс, из которого он был создан.  

### Метаклассы являются подклассами `type`  

Именно благодаря тому, что каждый класс является экземпляром `type`, у нас есть возможность реализовывать метаклассы. Мы можем создавать подклассы `type` для его настройки с помощью обычных методик ООП и синтаксиса классов. __Создание настроенных подклассов `type` позволяет реализовывать специальные виды классов__:
* `type` является классом, который генерирует классы, определяемые пользователем;
* метаклассы представляют собой подклассы класса `type`;
* объекты классов являются собой экземплярами класса `type` или какого-то из его подклассов;
* объекты экземпляров генерируются из классов.  

Для управления способом создания классов и дополнения их поведения необходимо лишь указать, что определяемый пользователем класс должен создаваться из определяемого пользователем метакласса, а не нормалнього класса `type`.  

> Процедура наследования выполняет поиск в словарях пространств имен экземпляров и классов, но классы также могут получить линию поведения от свого типа (т.е. метакласса), который не виден поиску при нормальном наследовании.

### Протокол оператора `class`  

Когда интерпретатор Python добирается до оператора `class`, он выполняет его вложенный блок кода, чтобы создать атрибута- все имена, которым присваиваются значения на верхнем уровне вложенного блока кода, становятся атрибутами в результирующем объекте класса.  

Говоря формально, чтобы это произошло, интерпретатор Python следует стандартному протоколу: в _коце оператора_ `class` и после выполнения всего вложенного в него кода в словаре пространства имен, соответствующем локальной области видимости класса, Python образается к объекту `type` для создания объекта _класс_:  

```python
класс = type(имя_класса, суперклассы, словарь_атрибутов)
```  

В `type` определен метод перегрузки операций `__call__`, который при вызове объекта `type` по очереди запускает два других метода:  

```python
type.__new__(класс_type, имя_класса, суперклассы, словарь_атрибутов)
type.__init__(класс, имя_класса, суперклассы, словарь_атрибутов)
```  

Метод `__new__` создает и возвращает новый объект _класс_, после чего метод `__init__` инициализирует вновь созданный объект. Именно они выступают в качестве привязок, которые метаклассы, являющиеся подклассами `type`, обычно применяют для настройки классов.  

Пример:  

```python
class Eggs: ...                     #Здесь нахдятся наследуемые имена

class Spam(Eggs):                   #Наследуется от Eggs
    data = 1                        #Атрибут данных класса
    def meth(self, arg):            #Атрибут метода класса 
        return self.data + arg
```  

Интерпретатор Python внутренне запустит вложенный блок кода для создания двух атрибутов класса (`data` и `meth`) и затем обратится к объекту `type` чтобы сгенерировать объект класса в конце оператора `class`:  

```python
Smap = type("Spam", ("Eggs",), {"data": 1, "meth": meth, "__module__": "__main__"})
```  

На самом деле вышеописанным образом можно создать класс динамически. Однако вызов `type` происходит автоматически в конце оператора `class`.  

## Объявление метаклассов  

Чтобы сообщить интерпретатору Python о необходимости создания класса с помощью специального метакласса, просто необходимо объявить метакласс для перехвата нормального вызова, создающего экземпляр, в определяемом пользователем классе.  

Желаемый аргумент указывается как _ключевой_ аргумент в заголовке оператора `class`:  

```python
class Spam(Eggs, metaclass=Meta):       #Допускаются обычные суперклассы: указываются первыми
```  

В такой форме суперклассы должны указываться перед метаклассами.  

### Координирование метаклассов  

После объявления конкретного метакласса, вызов для создания объекта _класса_, выполняемый в конце оператора `class`, модифицируется так, чтобы обращаться к метаклассу, а не к `type`:  

```python
класс = Meta(имя_класса, суперклассы, словарь_атрибутов)
```

Из-за того, что метакласс является подклассом `type`, метод `__call__` класса `type` делегирует вызов для создания и инициализации нового объекта _класс_ метаклассу, если в нем опрделены специальные версии следующих методов:  

```python
Meta.__new__(класс_type, имя_класса, суперклассы, словарь_атрибутов)
Meta.__init__(класс, имя_класса, суперклассы, словарь_атрибутов)
```  
```python
class Eggs: ...

class Spam(Eggs, metaclass=Meta):
    data = 1
    def meth(self, arg):
        return self.data + arg
```  

В конце этого оператора `class` интерпретатор Python внутренне запускает следующий код, чтобы создать объект _класса_:  

```python
Spam = Meta("Spam", ("Egs",), {"data": 1, "meth": meth, "__module__": "__main__"})
```  

Если метакласс определяет свои собственные версии метод `__new__` и `__init__`, тогда они будут вызываться по очереди унаследованным из класса `type` методом `__call__`, чтобы создать и инициализировать новый класс.  

## Реализация метаклассов  

Метаклассы реализуются с помощью нормальных оператор `class` и семантики Python. По определению это просто классы, унаследованные от `type`. Существенные отличия заключается лишь в том, что Python вызывает их _автоматически_ в конце оператора `class`, и что они обязанные придерживаться _интерфейса_, ожидаемого суперклассом `type`.

### Базовый метакласс  

Самым простым метаклассом может стать подкласс `type` с методом `__new__`, который создает объекта класса, запуская стандартую версию в `type`. Метод `__new__` такого металкасса запускается методом `__call__`, унаследованным из `type`; он обычно выполняет любую требующуюся настройку и вызывает метод `__new__` суперкласса `type`, чтобы создать и возвратить новый объект класса:  

```python
class Meta(type):
    def __new__(meta,classname, supers, classdict):
        return type.__new__(meta, classname, supers, classdict)
```  

В действительности данный метакласс ничего не делает, но демонстрирует способ перехвата привязки метакласса с целью настройки.  

Привер:  

```python
class MetaOne(type):
    def __new__(meta, classname, supers, classdict):
        print(f"In MetaOne.new:\n{meta}\n{classname}\n{supers}\n{classdict}\n")
        return type.__new__(meta, classname, supers, classdict)

class Eggs:
    pass
print("making class")
class Spam(Eggs, metaclass=MetaOne):
    data = 1
    def meth(self, arg):
        return self.data + arg
print("making instance")
X = Spam()
print(f"data: {X.data} {X.meth(2)}")
```  

### Настройка создания и инициализации  

Метаклассы также способны подключаться к протоколу `__init__`, запускаемому методом `__call__` объекта `type`. Метод `__init__` инициализирует уже созданный (с помощью `__new__`) класс, передаваемый в качестве аргумента. Метаклассы могут принять любую из двух или обе привязки для управления классом на стадии создания:  

```python
class MetaOne(type):
    def __new__(meta, classname, supers, classdict):
        print(f"In MetaOne.new:\n{meta}\n{classname}\n{supers}\n{classdict}\n")
        return type.__new__(meta, classname, supers, classdict)

    def __init__(Class, classname, supers, classdict):
        print(f"In MetaOne.init:\n{classname}\n{supers}\n{classdict}")
        print(f"... init class object: {list(Class.__dict__.keys())}")

class Eggs:
    pass
print("making class")
class Spam(Eggs, metaclass=MetaOne):
    data = 1
    def meth(self, arg):
        return self.data + arg
print("making instance")
X = Spam()
print(f"data: {X.data} {X.meth(2)}")
```  

В данной ситуации метод инициализации класса запускается после создания класса, но оба метода вызываются в конце оператора `class` до создания любых экземпляров. __И наоборо, метод `__init__` в `Spam` будет выполняться во время создания *экземпляра*, а метод `__init__` метакласса не затрагивает и не запускает его__.  

### Другие методики реализации метаклассов  

Переопределение методов `__new__` и `__init__` суперкласса `type` является самым распространенным способом вставить логику внутрь процесса создания объектов классов с привязкой к метаклассу, возможны и другие схемы.  

#### Использование простых фабричных функций:  

```python
def MetaFunc(classname, supers, classdict):
    print(f"In MetaFunc:\n{classname}\n{supers}\n{classdict}")
    return type(classname, supers, classdict)

class Eggs:
    pass
print("making class")
class Spam(Eggs, metaclass=MetaFunc):
    data = 1
    def meth(self, arg):
        return self.data + arg
print("making instance")
X = Spam()
print(f"data: {X.data} {X.meth(2)}")
```  

#### Перегрузка операций вызова, создающих классы, с помощью нормальных классов  

```python
class MetaObj:
    def __call__(self, classname, supers, classdict):
        print(f"In MetaObj.call:\n{classname}\n{supers}\n{classdict}\n")
        Class = self.__New__(classname, supers, classdict)
        self.__Init__(Class, classname, supers, classdict)
        return Class

    def __New__(self, classname, supers, classdict):
        print(f"In MetaObj.New:\n{classname}\n{supers}\n{classdict}\n")
        return type(classname, supers, classdict)

    def __Init__(self, Class, classname, supers, classdict):
        print(f"In MetaObj.Init:\n{classname}\n{supers}\n{classdict}\n")
        print(f"... init class object: {list(Class.__dict__.keys())}")

class Eggs:
    pass
print("making class")
class Spam(Eggs, metaclass=MetaObj()):
    data = 1
    def meth(self, arg):
        return self.data + arg
print("making instance")
X = Spam()
print(f"data: {X.data} {X.meth(2)}")
```  

#### Перегрузка операций вызова, создающих классы, с помощью метаклассов  

```python
# Классы тоже могут перехватывать вызовы
# но встроеенные операции ищуться в метаклассах, а не в суперклассах
class SuperMeta(type):
    def __call__(meta, classname, supers, classdict):
        print(f"In SuperMeta.call:\n{classname}\n{supers}\n{classdict}\n")
        return type.__call__(meta, classname, supers, classdict)

    def __init__(Class, classname, supers, classdict):
        print(f"In SuperMeta.init:\n{classname}\n{supers}\n{classdict}\n")
        print(f"...init class object: {list(Class.__dict__.keys())}")
    
print("making metaclass")

class SubMeta(type, metaclass=SuperMeta):
    def __new__(meta, classname, supers, classdict):
        print(f"In SubMeta.new:\n{classname}\n{supers}\n{classdict}\n")
        return type.__new__(meta, classname, supers, classdict)

    def __init__(Class, classname, supers, classdict):
        print(f"In SubMeta.init:\n{classname}\n{supers}\n{classdict}\n")
        print(f"... init class object: {list(Class.__dict__.keys())}")
        
class Eggs:
    pass
print("making class")
class Spam(Eggs, metaclass=SubMeta):
    data = 1
    def meth(self, arg):
        return self.data + arg
print("making instance")
X = Spam()
print(f"data: {X.data} {X.meth(2)}")
```  

Метод `__call__` из `SuperMeta` не запускается для вызова `SuperMeta` при создании `SubMeta` (взамен это направляется `type`), но запускается для вызова `SubMeta` при создании `Spam`. Обычного наследования от `SuperMeta` не будет достаточно для перехвата вызовов `SubMeta`: на самом деле поступать так с методами перегрузки операций нельзя: затем `Spam` получает метод `__call__` из `SuperMeta`, приводя к тому, что вызовы для создания экземпляров `Spam` потерпят неудачу до того, как будет создан хоть какойнибудь экземпляр.  

__ВАЖНО:__
> Метаклассы используются для создания объектов классов, но при вызове в роли метаклассов лишь генерируют экземпляры самих себя(т.е. экземплярами метаклассов являются сами метаклассы). Следовательно при неявном использовании встроенной операции, она ищется в метаклассе метакласса!!!!  

## Наследование и экземпляр  

Метаклассы сбивают с толку тем, что указываются способами, похожими на указание наследуемых суперклассов. Однако ниже описаны ключевые моменты, которые проясняют модел:  

* __Метаклассы наследуются от класса `type` (обычно)__  
  Несмотря на свою специальную роль, они следуют обычной модели ООП (и реализуются посредством оператора `class`).Например будучи подклассами `type` они могут переопределять методы объекта `type`, настраивая их должным образом. Метаклассы, как правило, переопределяют методы `__new__` и `__init__` класса `type` для настройки создания и инициализации классов. Хотя и реже, они могут переопределять такие методы как `__call__`, еси требуется напрямую перехватывать вызовы создания класса в конце (пусть и со сложностями, описанными выше). Метаклассы могут быть любыми вызываемыми объектами.
* __Объявления метаклассов наследуются подклассами__  
  Объявление `metaclass=метакласс` в определяемом пользователем классе _наследуется_ его нормальными подклассами, так что метакласс будет запускаться для создания каждого класса, который наследует эту спецификацию в цепочке наследования суперклассов.
* __Атрибуты метаклассов не наследуются экземплярами классов__
  Объявления метаклассов указывают отношение между _экземплярами_, которое отличается от того, что принято называть наследованием. Поскольку классы являются экземплярами метаклассов, определяемое метаклассом поведение применяется к классу, но не к создаваемым впоследствии экземплярам класса. Экземпляры получают поведение от своих классов и суперклассов, но не от метаклассов. Формально процедура наследования атрибутов для обычных экземпляров выполняет поиск только в словарях `__diсt__` экземпляра, его класса и всех суперклассов класса; для обычных экземпляров метаклассы в поиск при наследовании не включаются.
* __Атрибуты метаклассов получаются классами__
  Напротив, классы _получают_ методы своих метаклассов благодаря отношению между экземплярами. Это источник поведения классов, которое обрабатывает сами классы. Формально классы обзаводятся атрибутами метаклассов посредством своих ссылок `__class__` в точности как нормальные экземпляры получают имена от своих классов, но сначала предпринимается попытка наследования через поиск в `__dict__`: когда одно и тоже имя доступно классу в метаклассе и в суперклассе, то используется версия из суперкласса (через наследование), а не из метакласса (через экземпляр). Тем не менее, атрибут `__class__` класса не следует в его собственные экземпляры: атрибуты метаклассов делаются доступными их классам-экземплярам, но не экземплярам этих классов-экземпляров.  

### Пример  

```python
class MetaOne(type):
    def __new__(meta, classname, supers, classdict):                    #Переопределение метода type
        print(f"In MetaOne.new:\n{classname}\n{supers}\n{classdict}")
        return type.__new__(meta, classname, supers, classdict)

    def toast(self):
        return "toast"
    

class Super(metaclass=MetaOne):                                         #Метакласс наследуется также и подклассами
    def spam(self):                                                     #MetaOne запускается дважды для двух классов
        return "spam"
    
class Sub(Super):                                                       #Суперкласс: наследование или отношение между экземплярами
    def eggs(self):                                                     #Классы наследуют атрибуты от суперклассов
        return "eggs"                                                   #Но не от метаклассов
```  

Метакласс обрабатывает создание для _обоих_ клиентских классов, а _экземпляры_ наследуют атрибуты класса, но не атрибуты метакласса.  
В противоположность этому классы наследуют имена от своих суперклассов и обзаводятся именами из метакласса (который в данном примере сам унаследован из суперкласса).  
Методы, полученные из метакласса, привязываются к целевому классу, в то время как методы из нормальных классов являются несвязанными, если извлекаются через класс, но связанными, когда извлекаются через экземпляр.  

## Алгоритм наследования Python  

1. Начиная с *экземпляра* I, провести посиск в экземпляре, в его классе и суперклассах класса следующим образом:  
   а) Искать в словарях `__dict__` всех классов в `__mro__`, найденном в `__class__` экземпляра I.  
   б) Если на шаге а) был найден дескриптор данных, тогда вызвать его метод `__get__` и завершить работу.  
   в) Иначе возвратить значение в словаре `__dict__` экземпляра I.  
   г) Иначе вызвать дескриптор не данных или возвратить значение найденное на шаге а).  
2. Начиная с *класса* C, провести поиск в классе и суперклассах класса, в его дереве метаклассов следующим образом:  
   а) Искать в словарях `__dict__` всех метаклассов в `__mro__`, найденном в `__class__` класса C.  
   б) Если на шаге а) был найден дескриптор данных, тога вызвать его метод `__get__` и завершить работу.  
   в) Иначе возвратить значение в словаре `__dict__` класса C.  
   г) Иначе вызвать дескриптор не данных или возвратить значение найденное на шане а).  

> Исключения составляют всроенные имена  

## Методы метаклассов  

Методы в метаклассах обрабатывают их *классы-экземпляры* - не обычные объекты экземпляров, известные как `self`, а сами классы. В результате методы метаклассов становятся похожими по духу и форме на *методы классов*, хотя они по прежнему доступны только в области экземпляров метаклассов.  

### Методы метаклассов или методы классов  

Методы метаклассов доступны исключительно через класс и для привязки к классу не требуют явного объявления `classmethod` на уровне класса. Другими словами методы метоклассов можно воспринимать как неявные методы классов с ограниченной видимостью.  

```python
class A(type):
    def a(cls):                     #Метод метакласса: получает класс
        cls.x = cls.y + cls.z


class B(metaclass=A):               
    y, z = 11, 22
    @classmethod
    def b(cls):                     #Метод класса: получает класс
        return cls.x

B.a()                               #Вызов метода метакласса; является видимым только классу
print(B.x)                          #Создает данные в классе B, доступные нормальным экземплярам


I = B()
print(I.y)
print(I.z)
print(I.x)
print(I.b())                        #Метод класса: передается класс, а не экземпляр
                                    #Является видимым экземпляру

print(I.a())                        #Методы метакласса доступны только через класс
```  

### Перегрузка операций в методах метакласса  

Метаклассы могут задействовать перегрузку, чтобы сделать встроенные операции применимыми к их классам-экземплярам. Например, метод индексирования `__getitem__` в показанном ниже метаклассе представляет собой метакласса, который предназначен для обработки самих *классов*- т.е. классов, являющихся экземплярами метакласса, а не экземпляры этих классов, создаваемых впоследствии. Благодаря алгоритму наследования нормальные экземпляры классов вообще не наследуют имена, полученные через отношние экземпляра метакласса, хотя они могут обращаться к именам, присутствующим в их собственных классах:  

```python


class A(type):
    def __getitem__(cls, index):
        return cls.data[index]


class B(metaclass=A):
    data = "spam"

print(B[0])                 #Имена экземпляра метакласса: видимы только классу
print(B.__getitem__)
I = B()
print(I.data, B.data)       #Имена полученные нормальным наседованием: видимы экземпляру и классу
print(I[0])                 #Ошибка !!!
```  

## Пример: добавление методов в классы  

Есть два распространенных сценариев использования метаклассов: добавление методов в класс и автоматическое декорирование всех методов.  

### Ручное дополнение  

```python
class Client1:
    def __init__(self, value):
        self.value = value
    
    def spam(self):
        return self.value * 2 


class Client2:
    value = "ni?"


def eggsfunc(obj):
    return obj.value * 4

def hamfunc(obj, value):
    return value + "ham"

Client1.eggs = eggsfunc
Client1.ham = hamfunc

Client2.eggs = eggsfunc
Client2.ham = hamfunc

X = Client1("Ni")
print(X.spam())
print(X.eggs())
print(X.ham("bacon"))

Y = Client2()
print(Y.eggs())
print(Y.ham("bacon"))
```  

Данный прием работает по причине того, что методы всегда можно присвоить классу после его создания (функции должны иметь дополнительный первый аргумент для получения `self`).  

__Недостаток__: необходимость повторять код дополнения для каждого класса, которому нужны новые методы.

### Дополнение на основе метаклассов  

```python
def eggsfunc(obj):
    return obj.value * 4


def hamfunc(obj, value):
    return value + "ham"

class Extender(type):
    def __new__(meta, classname, supers, classdict):
        classdict["eggs"] = eggsfunc
        classdict["ham"] = hamfunc
        return type.__new__(meta, classname, supers, classdict)


class Client1(metaclass=Extender):
    def __init__(self, value):
        self.value = value

    def spam(self):
        return self.value * 2

class Client2(metaclass=Extender):
    value = "ni?"

X = Client1("Ni!")
print(X.spam())
print(X.eggs())
print(X.ham("bacon"))

Y = Client2()
print(Y.eggs())
print(Y.ham("bacon"))
```  

Структура на базе метаклассов поддерживает более динамическое поведение. Например целевой класс можно конфигурировать на основе произвольной логики во время выполнения:  

```python
class MetaExtend(type):
    def __new__(meta, classname, supers, classdict):
        if sometest():
            classdict["eggs"] = eggsfunc1
        else:
            classdict["eggs"] = eggsfunc2
        if someothertest():
            classdict["hum"] = hunfunc1
        else:
            classdict["hum"] = hunfunc2
        return type.__new__(meta, classname, supers, classdict)
```  

## Метаклассы против декраторов  

Декораторы классов часто выполняют те же роли, что и метаклассы. Т.е. декораторы классов способны управлять классами, хоть и лучше использовать их для управления экземплярами. Однако метаклассы, которые управляют классами, также способны управлять нормальными экземплярами (__хотя требуют для этого дополнительного шага__):

* Декораторы классов могут управлять классами и экземплярами, но не создавать классы обычным образом  
* Метаклассы могу упавлять классами и экземплярами, но не для экземпляров требуется дополнительная работа  

__Пример с декоратором класса__:  

```python
def tracer(aClass):
    class Wrapper:
        def __init__(self, *pargs, **kwargs):
            self.wrapped = aClass(*pargs, **kwargs)
        
        def __getattr__(self, attrname):
            print(f"Trace {attrname}")
            return getattr(self.wrapped, attrname)
    return Wrapper


@tracer
class Person:
    def __init__(self, name, job, pay):
        self.name = name
        self.job = job
        self.pay = pay
    
    def payPerson(self):
        return self.pay


ex = Person("Evgeniy", "python developer", 1000)
print(ex.name)
print(ex.payPerson())
```

Тот же пример с метаклассом:  

```python
def tracer(classname, supers, classdict):
    aClass = type(classname, supers, classdict)
    class Wrapper:
        def __init__(self, *args, **kwargs):
            self.wrapped = aClass(*args, **kwargs)
        
        def __getattr__(self, attrname):
            print(f"Trace {attrname}")
            return getattr(self.wrapped, attrname)
    return Wrapper

class Person(metaclass=tracer):
    def __init__(self, name, job, pay):
        self.name = name
        self.job = job
        self.pay = pay
    
    def payPerson(self):
        return self.pay


ex = Person("Evgeniy", "python developer", 1000)
print(ex.name)
print(ex.payPerson())
```  

* Поскольку декораторы запускаются после создания класса, в ролях с созднием классов они влекут за собой дполнительный шаг во время выполнения.
* Поскольку метаклассы должны создавать классы, в ролях с управлением экземплярами они влекут за собой дополнительный шаг на этапе реализации.  

## Пример: применение декораторов к методам  

### Трасировка с помощью декорирования вручную  

```python
import time

def tracer(func):
    calls = 0 
    def onCall(*pargs, **kwargs):
        nonlocal calls
        calls += 1
        print(f"call {calls} to {func.__name__}")
        return func(*pargs, **kwargs)
    return onCall


def timer(label="", tracer=True):
    def onDecorator(func):
        alltime = 0
        def onCall(*pargs, **kwargs):
            nonlocal alltime
            start = time.time()
            result = func(*pargs, **kwargs)
            elapsed = time.time() - start
            alltime += elapsed
            if tracer:
                print(f"{label} {func.__name__} : {elapsed}, {alltime}")
            return result
        return onCall
    return onDecorator


class Person:
    @tracer
    def __init__(self, name, job, pay):
        self.name = name
        self.job = job
        self.pay = pay

    @tracer
    def giveRise(self, percent):
        self.pay *= (1 + percent)

    @tracer
    def lastName(self):
        return self.name.split()[-1]
```  

### Трассировка с помощью метаклассов и декораторов  

```python
import time

from types import FunctionType

class MetaTrace(type):
    def __new__(meta, classname, supers, classdict):
        for attr, attrval in classdict.items():
            if type(attrval) == FunctionType:
                classdict[attr] = tracer(attrval)
        return type.__new__(meta, classname, supers, classdict)


def tracer(func):
    calls = 0 
    def onCall(*pargs, **kwargs):
        nonlocal calls
        calls += 1
        print(f"call {calls} to {func.__name__}")
        return func(*pargs, **kwargs)
    return onCall


def timer(label="", tracer=True):
    def onDecorator(func):
        alltime = 0
        def onCall(*pargs, **kwargs):
            nonlocal alltime
            start = time.time()
            result = func(*pargs, **kwargs)
            elapsed = time.time() - start
            alltime += elapsed
            if tracer:
                print(f"{label} {func.__name__} : {elapsed}, {alltime}")
            return result
        return onCall
    return onDecorator


class Person(metaclass=MetaTrace):
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    def giveRise(self, percent):
        self.pay *= (1 + percent)

    def lastName(self):
        return self.name.split()[-1]

bob = Person("Bob Smith", 1000)
sue = Person("Sue Jones", 100000)
print(bob.name, sue.name)
sue.giveRise(.10)
print(sue.pay)
print(bob.lastName(), sue.lastName())
```